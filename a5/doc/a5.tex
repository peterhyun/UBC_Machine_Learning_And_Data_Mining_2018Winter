\documentclass{article}

\usepackage{fullpage}
\usepackage{color}
\usepackage{amsmath}
\usepackage{url}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{parskip}
\usepackage{amssymb}
\usepackage{nicefrac}
\usepackage{listings} % For displaying code
\usepackage{algorithm2e} % pseudo-code
\usepackage{textcomp}

\def\rubric#1{\gre{Rubric: \{#1\}}}{}

% Colors
\definecolor{blu}{rgb}{0,0,1}
\def\blu#1{{\color{blu}#1}}
\definecolor{gre}{rgb}{0,.5,0}
\def\gre#1{{\color{gre}#1}}
\definecolor{red}{rgb}{1,0,0}
\def\red#1{{\color{red}#1}}
\def\norm#1{\|#1\|}
\definecolor{vio}{rgb}{0.4,0,0.6}
\def\vio#1{{\color{vio}#1}}
\definecolor{gray}{rgb}{0.85,0.85,0.85}
\def\vio#1{{\color{gray}#1}}

% Math
\def\R{\mathbb{R}}
\def\argmax{\mathop{\rm arg\,max}}
\def\argmin{\mathop{\rm arg\,min}}
\newcommand{\mat}[1]{\begin{bmatrix}#1\end{bmatrix}}
\newcommand{\alignStar}[1]{\begin{align*}#1\end{align*}}
\def\half{\frac 1 2}

% LaTeX
\newcommand{\fig}[2]{\includegraphics[width=#1\textwidth]{#2}}
\newcommand{\centerfig}[2]{\begin{center}\includegraphics[width=#1\textwidth]{#2}\end{center}}
\newcommand{\matCode}[1]{\lstinputlisting[language=Matlab]{a2f/#1.m}}
\def\items#1{\begin{itemize}#1\end{itemize}}
\def\enum#1{\begin{enumerate}#1\end{enumerate}}

\lstset{language=Python, 
        basicstyle=\ttfamily\small, 
        keywordstyle=\color{blue},
        commentstyle=\color{gray},
        stringstyle=\color{red},
        showstringspaces=false,
        identifierstyle=\color{vio},
        procnamekeys={def,class}}

\begin{document}


\title{CPSC 340 Assignment 5 (due Monday March 18 at 11:55pm)}
\date{}
\maketitle

\vspace{-7em}


\section*{Instructions}
\rubric{mechanics:5}

\textbf{IMPORTANT!!! Before proceeding, please carefully read the general homework instructions at} \url{https://www.cs.ubc.ca/~fwood/CS340/homework/}. The above 5 points are for following the submission instructions. You can ignore the words ``mechanics'', ``reasoning'', etc.

\vspace{1em}
We use \blu{blue} to highlight the deliverables that you must answer/do/submit with the assignment.


\section{Kernel Logistic Regresion}

If you run \verb|python main.py -q 1| it will load a synthetic 2D data set, split it into train/validation sets, and then perform regular logistic regression and kernel logistic regression (both without an intercept term, for simplicity). You'll observe that the error values and plots generated look the same since the kernel being used is the linear kernel (i.e., the kernel corresponding to no change of basis).

\subsection{Implementing kernels}
\rubric{code:5}

 \blu{Implement the polynomial kernel and the RBF kernel for logistic regression. Report your training/validation errors and submit the plots generated for each case}. You should use the hyperparameters $p=2$ and $\sigma=0.5$ respectively, and $\lambda=0.01$ for the regularization strength.
 
 \begin{lstlisting}
 def kernel_RBF(X1, X2, sigma=1):
    t, d = X1.shape
    n, d = X2.shape
    #print(d)
    temp = np.zeros((t,n))
    for i in range(t):
        for j in range(n):
            temp2 = np.linalg.norm(X1[i,:]-X2[j,:])
            temp[i,j] = temp2*temp2/(-2*sigma*sigma)
    return np.exp(temp)
    #print('In kernel_RBF, temp shape is '+str(temp.shape))

def kernel_poly(X1, X2, p=2):
    temp = X1@X2.T
    temp = temp+1
    #print('In kernel_poly, temp shape is '+str(temp.shape))
    return np.power(temp, p)
 \end{lstlisting}
 
 \red{For polynomial kernel: \newline
Training error 0.183 \\
Validation error 0.170 \\
\centerfig{.7}{./figs/logRegPolynomialKernel.png}
}
\red{
For RBF kernel: \newline
Training error 0.127 \newline
Validation error 0.090}

\centerfig{.7}{./figs/logRegRBFKernel.png}



\subsection{Hyperparameter search}
\rubric{code:3}

For the RBF kernel logistic regression, consider the hyperparameters values $\sigma=10^m$ for $m=-2,-1,\ldots,2$ and $\lambda=10^m$ for $m=-4,-3,\ldots,0$. \blu{In \texttt{main.py}, sweep over the possible combinations of these hyperparameter values. Report the hyperparameter values that yield the best training error and the hyperparameter values that yield the best validation error. Include the plot for each.}

Note: on the job you might choose to use a tool like scikit-learn's \texttt{GridSearchCV} to implement the grid search, but here we are asking you to implement it yourself by looping over the hyperparameter values.

\red{For the hyperparameter that yields the best training error 0.000, I got $\sigma = 0.01$, $\lambda = 0.0001, 0.001, 0.01, 0.1$
They have almost identical plots so I will just include one of them.
}

\centerfig{.7}{./figs/BestTrainingError.png}

\red{For the hyperparamter that yields the best validation error 0.120, I got $\sigma = 0.1$, $\lambda = 1$ The plot is as follows.}

\centerfig{.7}{./figs/BestValidationError.png}

\subsection{Reflection}
\rubric{reasoning:1}

Briefly discuss the best hyperparameters you found in the previous part, and their associated plots. Was the training error minimized by the values you expected, given the ways that $\sigma$ and $\lambda$ affect the fundamental tradeoff?

\red{The training error being the lowest when the $\lambda$ is very small matches the expectation as increasing the $\lambda$ value tends to strengthen the power of regularization, which tends to increase training error in return of less validation error. }


\section{MAP Estimation}
\rubric{reasoning:8}

In class, we considered MAP estimation in a regression model where we assumed that:
\items{
\item The likelihood $p(y_i \mid x_i, w)$ is a normal distribution with a mean of $w^Tx_i$ and a variance of $1$.
\item The prior for each variable $j$, $p(w_j)$, is a normal distribution with a mean of zero and a variance of $\lambda^{-1}$.
}
Under these assumptions, we showed that this leads to the standard L2-regularized least squares objective function,
\[
f(w) = \frac{1}{2}\norm{Xw - y}^2 + \frac \lambda 2 \norm{w}^2,
\]
which is the negative log likelihood (NLL) under these assumptions (ignoring an irrelevant constant).
\blu{For each of the alternate assumptions below, show how the loss function would change} (simplifying as much as possible):
\enum{
\item We use a Laplace likelihood with a mean of $w^Tx_i$ and a scale of $1$, and we use a zero-mean Gaussian prior with a variance of $\sigma^2$.
\[
p(y_i \mid x_i, w) = \frac 1 2 \exp(-|w^Tx_i - y_i|), \quad p(w_j) = \frac{1}{\sqrt{2\pi}\sigma}\exp\left(-\frac{w_j^2}{2\sigma^2}\right).
\]
\red{
\[
 \arg\max_{w} p(y \mid X, w)p(w) = \arg\max_{w} \Pi_{i=1}^n \frac 1 2 \exp(-|w^Tx_i - y_i|) +  \arg\max_{w} \Pi_{j=1}^d \frac{1}{\sqrt{2\pi}\sigma}\exp\left(-\frac{w_j^2}{2\sigma^2}\right).
\]
\[
 \arg\max_{w} p(y \mid X, w)p(w) = \arg\min_{w} - \{ \Sigma_{i=1}^n \log(\exp(-|w^Tx_i - y_i|)) +  \arg\min_{w} \Sigma_{j=1}^d \log(\exp\left(-\frac{w_j^2}{2\sigma^2}\right))\}.
\]
\[
 \arg\max_{w} p(y \mid X, w)p(w) = \arg\min_{w} \norm{Xw - y}_1 + \frac{\norm{w}^2}{2\sigma^2}.
\]
}
\item We use a Gaussian likelihood where each datapoint has its own variance $\sigma_i^2$, and where we use a zero-mean Laplace prior with a vairance of $\lambda^{-1}$.
\[
p(y_i \mid x_i,w) = \frac{1}{\sqrt{2\sigma_i^2\pi}}\exp\left(-\frac{(w^Tx_i - y_i)^2}{2\sigma_i^2}\right), \quad p(w_j) = \frac{\lambda}{2}\exp(-\lambda|w_j|).
\]
You can use $\Sigma$ as a diagonal matrix that has the values $\sigma_i^2$ along the diagonal.
\red{\[
 \arg\max_{w} p(y\mid X, w)p(w) = \arg\min_{w} \frac{\norm{Xw - y}^2}{2\norm{\Sigma}^2} + \frac{\lambda\norm{w}_1}{2}.
\]}
\item We use a (very robust) student $t$ likelihood with a mean of $w^Tx_i$ and $\nu$ degrees of freedom, and a zero-mean Gaussian prior with a variance of $\lambda^{-1}$,
\[
p(y_i | x_i, w) = \frac{\Gamma\left(\frac{\nu + 1}{2}\right)}{\sqrt{\nu\pi}\Gamma\left(\frac \nu 2\right)}\left(1 + \frac{(w^Tx_i - y_i)^2}{\nu}\right)^{-\frac{\nu+1}{2}}, \quad p(w_j) = \frac{\sqrt{\lambda}}{\sqrt{2\pi}}\exp\left(-\lambda\frac{w_j^2}{2}\right).
\]
where $\Gamma$ is the ``gamma" function (which is always non-negative).
\red{\[
 \arg\max_{w} p(y\mid X, w)p(w) = \arg\min_{w} -\log(\Gamma\left(\frac{\nu + 1}{2}\right)) + \log(\sqrt{\nu\pi}\Gamma\left(\frac \nu 2\right)) + \frac{\nu+1}{2}\log\left(\left(1 + \frac{\norm{Xw - y}^2}{\nu}\right)\right) + \frac{\lambda\norm{w}^2}{2}.
\]}
\item We use a Poisson-distributed likelihood (for the case where $y_i$ represents counts), and we use a uniform prior for some constant $\kappa$,
\[
p(y_i | w^Tx_i) = \frac{\exp(y_iw^Tx_i)\exp(-\exp(w^Tx_i))}{y_i!}, \quad p(w_j) \propto \kappa.
\]
(This prior is 	``improper'' since $w\in\R^d$ but it doesn't integrate to 1 over this domain, but nevertheless the posterior will be a proper distribution.)
\red{\[
 \arg\max_{w} p(y|Xw)p(w) = \arg\min_{w} \exp(Xw) + y^TXw + y - \log(\kappa).
\]}
}


\section{Principal Component Analysis}
\rubric{reasoning:3}


Consider the following dataset, containing 5 examples with 2 features each:
\begin{center}
\begin{tabular}{cc}
$x_1$ & $x_2$\\
\hline
-4 & 3\\
0 & 1\\
-2 & 2\\
4 & -1\\
2 & 0\\
\end{tabular}
\end{center}
Recall that with PCA we usually assume that the PCs are normalized ($\norm{w} = 1$), we need to center the data before we apply PCA, and that the direction of the first PC is the one that minimizes the orthogonal distance to all data points.
\blu{
\enum{
\item What is the first principal component?
\red{$w = (\frac{2}{\sqrt{5}},\frac{-1}{\sqrt{5}})$}
\item What is the reconstruction loss (L2 norm squared) of the point (-3, 2.5)? (Show your work.)
\red{
\[
W=
  \begin{bmatrix}
    \frac{2}{\sqrt{5}} & \frac{-1}{\sqrt{5}} \\
  \end{bmatrix}
\]
$\mu_{1} = 0$, $\mu_{2} = 1$
\[
\Tilde{X}=
  \begin{bmatrix}
    -3 & 1.5 \\
  \end{bmatrix}
\]
$\Tilde{Z} = -1.5\sqrt{5}$ \newline
Therefore the reconstruction error is \newline  $||\Tilde{Z}W-\Tilde{X}||_{F} = 0$
}
\item What is the reconstruction loss (L2 norm squared) of the point (-3, 2)? (Show your work.)
}
\red{
\[
\Tilde{X}=
  \begin{bmatrix}
    -3 & 1 \\
  \end{bmatrix}
\]\newline W, $u_{j}$ is same as above.\newline
 $\Tilde{Z}=\frac{-7\sqrt{5}}{5}$\newline
 Therefore the reconstruction error is \newline  $||\Tilde{Z}W-\Tilde{X}||_{F} = 0.2$\newline
}
}
Hint: it may help (a lot) to plot the data before you start this question.



\section{PCA Generalizations}

\subsection{Robust PCA}
\rubric{code:10}

If you run \verb|python main -q 4.1| the code will load a dataset $X$ where each row contains the pixels from a single frame of a video of a highway. The demo applies PCA to this dataset and then uses this to reconstruct the original image.
It then shows the following 3 images for each frame:
\enum{
\item The original frame.
\item The reconstruction based on PCA.
\item A binary image showing locations where the reconstruction error is non-trivial.
}
Recently, latent-factor models have been proposed as a strategy for ``background subtraction'': trying to separate objects from their background. In this case, the background is the highway and the objects are the cars on the highway. In this demo, we see that PCA does an OK job of identifying the cars on the highway in that it does tend to identify the locations of cars. However, the results aren't great as it identifies quite a few irrelevant parts of the image as objects.

Robust PCA is a variation on PCA where we replace the L2-norm with the L1-norm,
\[
f(Z,W) = \sum_{i=1}^n\sum_{j=1}^d |\langle w^j, z_i\rangle - x_{ij}|,
\]
and it has recently been proposed as a more effective model for background subtraction. \blu{Complete the class \emph{pca.RobustPCA},
that uses a smooth approximation to the absolute value to implement robust PCA. Briefly comment on the results.} 
Note: in its current state, \emph{pca.RobustPCA} is just a copy of \emph{pca.AlternativePCA}, which is why the two rows of images are identical.

Hint: most of the work has been done for you in the class \emph{pca.AlternativePCA}.
This work implements an alternating minimization approach to minimizing the (L2) PCA objective (without enforcing orthogonality). This gradient-based approach to PCA can be modified to use a smooth approximation of the L1-norm. Note that the log-sum-exp approximation to the absolute value may be hard to get working due to numerical issues, and a numerically-nicer approach is to use the ``multi-quadric'' approximation:
\[
|\alpha| \approx \sqrt{\alpha^2 + \epsilon},
\]
where $\epsilon$ controls the accuracy of the approximation (a typical value of $\epsilon$ is $0.0001$).
 \begin{lstlisting}
class RobustPCA(AlternativePCA):
    '''
    Solves the PCA problem min_Z,W (Z*W-X)^2 using gradient descent
    '''
    def fit(self, X):
        n,d = X.shape
        k = self.k
        self.mu = np.mean(X,0)
        X = X - self.mu

        # Randomly initial Z, W
        z = np.random.randn(n*k)
        w = np.random.randn(k*d)

        for i in range(10): # do 10 "outer loop" iterations
            z, f = findMin(self._fun_obj_z, z, 10, w, X, k)
            w, f = findMin(self._fun_obj_w, w, 10, z, X, k)
            print('Iteration %d, loss = %.1f' % (i, f))

        self.W = w.reshape(k,d)

    def compress(self, X):
        n,d = X.shape
        k = self.k
        X = X - self.mu
        # We didn't enforce that W was orthogonal 
        # so we need to optimize to find Z
        # (or do some matrix operations)
        z = np.zeros(n*k)
        z,f = findMin(self._fun_obj_z, z, 100, self.W.flatten(), X, k)
        Z = z.reshape(n,k)
        return Z

    def _fun_obj_z(self, z, w, X, k):
        n,d = X.shape
        Z = z.reshape(n,k)
        W = w.reshape(k,d)

        R = np.dot(Z,W) - X
        f = np.sum(np.absolute(R))
        g = np.dot(R/np.sqrt(R**2 + 0.0001), W.transpose())
        return f, g.flatten()

    def _fun_obj_w(self, w, z, X, k):
        n,d = X.shape
        Z = z.reshape(n,k)
        W = w.reshape(k,d)

        R = np.dot(Z,W) - X
        f = np.sum(np.absolute(R))
        g = np.dot(Z.transpose(), R/np.sqrt(R**2 + 0.0001))
        return f, g.flatten()
 \end{lstlisting}
\red{The results for RobustPCA are better than the results for the AlternativePCA. The reconstruction error is non-trivial for more points in the image for Alternative PCA which indicates that L2 gives more false positives.}


\subsection{Reflection}
\rubric{reasoning:3}

\enum{
\item Briefly explain why using the L1 loss might be more suitable for this task than L2. \red{
L2 norm identifies a few irrelevant parts of the image as objects. This is because L2 norm is too sensitive to outliers. As L1 loss is more robust to outliers it is more suitable for this task.
}
\item How does the number of video frames and the size of each frame relate to $n$, $d$, and/or $k$? \red{ $n$ = number of frames, $d$ = size of each frame}
\item What would the effect be of changing the threshold (see code) in terms of false positives (cars we identify that aren't really there) and false negatives (real cars that we fail to identify)? \red{Reducing the threshold increases the false positives (reconstruction error is minimal) whereas increasing the threshold increases the false negatives.}
}

\section{Very-Short Answer Questions}
\rubric{reasoning:11}

\enum{
\item Assuming we want to use the original features (no change of basis) in a linear model, what is an advantage of the ``other'' normal equations over the original normal equations? \red{When finding the minimum using $w = X^T(XX^T + \lambda I)^{-1}y$, $(XX^T + \lambda I)$ will be a $n \times n$ system instead of $d \times d$ system.}
\item In class we argued that it's possible to make a kernel version of $k$-means clustering. What would an advantage of kernels be in this context? \red{It would be able to separate non-convex data.}
\item In the language of loss functions and regularization, what is the difference between MLE and MAP?
\red{MLE maximizes the likelihood (or minimizes the loss) while MAP maximizes the likelihood times the prior (minimizes the summation of the loss and the regularizer). }
\item What is the difference between a generative model and a discriminative model? \red{Generative models model the distribution of individual classes (estimate $P(X|y)$ to deduce $P(y|X)$) but the discriminative models learn the decision boundary (estimate $P(y|X)$ directly).}
\item With PCA, is it possible for the loss to increase if $k$ is increased? Briefly justify your answer.
\red{No it is not possible for the loss to increase. The whole purpose of PCA is to compress the dimensions of X with the risk that the original data X might not preserve it's values perfectly. If the dimension k increases then there will be less loss with the cost of less compressing.}
\item What does ``label switching'' mean in the context of PCA? \red{When k is bigger than 1, the exact same basis that forms the matrix W can be interpreted in different labels as the span of these basis vectors are the same.}
\item Why doesn't it make sense to do PCA with $k > d$? \red{The application of PCA is to reduce the dimensions from $d$ to $k$. If $k > d$, we are increasing the dimensionality of the data. }
\item In terms of the matrices associated with PCA ($X$, $W$, $Z$, $\hat{X}$), where would an ``eigenface'' be stored? \red{$W$}
\item What is an advantage and a disadvantage of using stochatic gradient over SVD when doing PCA? \red{Using stochastic gradient, we can fit huge datasets where SVD is too expensive. However SGD does not enforce the uniqueness constraints (sensitive to initialization and does not force normalization).}
\item Which of the following step-size sequences lead to convergence of stochastic gradient to a stationary point?
\enum{
\item $\alpha^t = 1/t^2$. \red{yes}
\item $\alpha^t = 1/t$. \red{yes}
\item $\alpha^t = 1/\sqrt{t}$. \red{yes}
\item $\alpha^t = 1$. \red{no}
}
\item We discussed ``global'' vs. ``local'' features for e-mail classification. What is an advantage of using global features, and what is advantage of using local features? \red{Using global features helps makes predictions when we do not have any information about the user. Using local features makes the predictions personal.}
}


\end{document}